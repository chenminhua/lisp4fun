;In many ways they seem like just a funny kind of function--they're written in Lisp,
;they take arguments and return results, and they allow you to abstract away distracting details. 
;Yet despite these many similarities, macros operate at a different level than functions and create a totally different kind of abstraction.

;When you write macros, you're writing programs that will be used by the compiler to generate the code that will then be compiled. 
;Only after all the macros have been fully expanded and the resulting code compiled can the program actually be run. 
;The time when macros run is called macro expansion time; this is distinct from runtime, when regular code, including the code generated by macros, runs.
(print
(if (> 2 3) "Yup" "Nope")
)

; progn 用于执行一组操作
(if (< 2 3) 
(progn
    (print "hello")
    (print "world")))

;(defmacro when (condition &rest body)
;  `(if ,condition (progn ,@body)))
(when (< 2 3)
    (print "hello")
    (print "when")
    (print "macros"))

;(defmacro unless (condition &rest body)
;  `(if (not ,condition) (progn ,@body)))
(unless (< 4 3)
    (print "hello")
    (print "unless")
    (print "macros"))

;; (defun primep (number)
;;     (when (> number 1)
;;     (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

;; (defun next-prime (number)
;;   (loop for n from number when (primep n) return n))

;; (defmacro do-primes (var-and-range &rest body)
;;     (let ((var (first var-and-range))
;;         (start (second var-and-range))
;;         (end (third var-and-range)))
;;     `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
;;          ((> ,var ,end))
;;        ,@body)))

;; exp
;; atom
;; number
;; integer
;; character
;; vector
;; symbol
;; list
;; function
;; special form
;; macros

